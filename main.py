# -*- coding: utf-8 -*-
"""Untitled10.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1TttUKpbHbwRq6wn7AImbUJXL_aX1kUZY
"""

## realizar conexion:


import mlflow
import os
from google.colab import userdata

# Conexión con Dagshub
mlflow.set_tracking_uri("https://dagshub.com/tomas.carvajal1993/Proyecto_evaluacion_crediticia.mlflow")
os.environ["MLFLOW_TRACKING_USERNAME"] = userdata.get("DAGSHUB_USERNAME")
os.environ["MLFLOW_TRACKING_PASSWORD"] = userdata.get("DAGSHUB_PASSWORD")
mlflow.set_experiment("evaluacion_crediticia")

import pandas as pd
file_id = "1J5aYITW1-zYm9N8ktTTcg2aXUnR5DsRZ"
url = f"https://drive.google.com/uc?id={file_id}"
df = pd.read_csv(url)
df.head()

from sklearn.preprocessing import OneHotEncoder
from sklearn.model_selection import train_test_split

# 1. Variable objetivo
y = df["otorgado_credito"]
X = df.drop("otorgado_credito", axis=1)

# 2. Expandir productos financieros como multietiquetas
productos = X['producto_financiero'].str.get_dummies(sep=', ')
X = pd.concat([X.drop(columns=['producto_financiero']), productos], axis=1)

# 3. Detectar columnas categóricas (tipo object)
categoricas = X.select_dtypes(include="object").columns.tolist()
print("Categoricas detectadas:", categoricas)

# 4. OneHotEncoding si hay categóricas
if categoricas:
    ohe = OneHotEncoder(sparse_output=False, handle_unknown='ignore')  # <-- aquí el fix
    X_cat_ohe = ohe.fit_transform(X[categoricas])
    X_cat_df = pd.DataFrame(X_cat_ohe, columns=ohe.get_feature_names_out(categoricas), index=X.index)
    X = pd.concat([X.drop(columns=categoricas), X_cat_df], axis=1)

# 5. Dataset final
X_final = X.copy()

# 6. División train/test
X_train, X_test, y_train, y_test = train_test_split(X_final, y, test_size=0.3, random_state=42)

from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import accuracy_score, f1_score, precision_score, recall_score
import mlflow
import mlflow.sklearn
import joblib

# Iniciar experimento
with mlflow.start_run(run_name="RandomForest_crediticia"):

    # Entrenamiento
    model = RandomForestClassifier(random_state=42)
    model.fit(X_train, y_train)

    # Predicciones
    y_pred = model.predict(X_test)

    # Métricas
    acc = accuracy_score(y_test, y_pred)
    f1 = f1_score(y_test, y_pred)
    prec = precision_score(y_test, y_pred)
    rec = recall_score(y_test, y_pred)

    # Registrar métricas en MLflow
    mlflow.log_metric("accuracy", acc)
    mlflow.log_metric("f1_score", f1)
    mlflow.log_metric("precision", prec)
    mlflow.log_metric("recall", rec)

    # Guardar modelo y encoder localmente
    joblib.dump(model, "modelo_rf.pkl")
    joblib.dump(ohe, "onehot_encoder.pkl")
    joblib.dump(productos.columns.tolist(), "columnas_productos.pkl")

    # Registrar artefactos
    mlflow.log_artifact("modelo_rf.pkl", artifact_path="modelo_credito")
    mlflow.log_artifact("onehot_encoder.pkl")
    mlflow.log_artifact("columnas_productos.pkl")

import json
import pandas as pd
import joblib
import numpy as np

# Cargar modelo y preprocesadores
modelo = joblib.load("modelo_rf.pkl")
encoder = joblib.load("onehot_encoder.pkl")
cols_productos = joblib.load("columnas_productos.pkl")

# Función que transforma y predice
def predecir_credito(input_json):
    # Convertir JSON a DataFrame
    df_input = pd.DataFrame([input_json])

    # Separar productos financieros múltiples (lista o string)
    productos_cliente = df_input["producto_financiero"]
    if isinstance(productos_cliente[0], list):
        productos_separados = productos_cliente.apply(lambda x: ', '.join(x))
    else:
        productos_separados = productos_cliente

    dummies_productos = productos_separados.str.get_dummies(sep=', ')

    # Asegurar todas las columnas del entrenamiento están presentes
    for col in cols_productos:
        if col not in dummies_productos:
            dummies_productos[col] = 0
    dummies_productos = dummies_productos[cols_productos]  # ordenar columnas

    df_input = df_input.drop(columns=["producto_financiero"])

    # Codificar variables categóricas
    cat_cols = encoder.feature_names_in_
    cat_encoded = encoder.transform(df_input[cat_cols])
    df_cat_encoded = pd.DataFrame(cat_encoded, columns=encoder.get_feature_names_out(cat_cols))

    # Juntar todo
    df_input_final = pd.concat([
        df_input.drop(columns=cat_cols).reset_index(drop=True),
        df_cat_encoded.reset_index(drop=True),
        dummies_productos.reset_index(drop=True)
    ], axis=1)

    # Predicción
    pred = modelo.predict(df_input_final)[0]
    return int(pred)

from fastapi import FastAPI
from pydantic import BaseModel
import joblib
import pandas as pd

# Cargar artefactos
modelo = joblib.load("modelo_rf.pkl")
encoder = joblib.load("onehot_encoder.pkl")
cols_productos = joblib.load("columnas_productos.pkl")

# Definir estructura del JSON de entrada
class SolicitudCredito(BaseModel):
    edad: int
    sexo: str
    region: str
    estado_civil: str
    nivel_educacional: str
    personas_a_cargo: str
    trabaja_actualmente: str
    tipo_contrato: str
    antiguedad_empleo: str
    tramo_ingresos: str
    producto_financiero: list[str]
    instituciones_financieras: str
    pago_mensual: str
    solicito_credito_ult_6m: str

# Crear app
app = FastAPI()

# Endpoint de prueba
@app.get("/")
def home():
    return {"mensaje": "API de evaluación crediticia activa"}

# Endpoint de predicción
@app.post("/predict")
def predict(data: SolicitudCredito):
    input_dict = data.dict()

    # Paso 1: convertir en DataFrame
    df_input = pd.DataFrame([input_dict])

    # Paso 2: productos financieros
    productos = df_input["producto_financiero"].apply(lambda x: ', '.join(x))
    dummies_productos = productos.str.get_dummies(sep=', ')

    for col in cols_productos:
        if col not in dummies_productos:
            dummies_productos[col] = 0
    dummies_productos = dummies_productos[cols_productos]

    df_input = df_input.drop(columns=["producto_financiero"])

    # Paso 3: one-hot encoding
    cat_cols = encoder.feature_names_in_
    encoded = encoder.transform(df_input[cat_cols])
    df_encoded = pd.DataFrame(encoded, columns=encoder.get_feature_names_out(cat_cols))

    # Paso 4: ensamblar input final
    df_final = pd.concat([
        df_input.drop(columns=cat_cols).reset_index(drop=True),
        df_encoded.reset_index(drop=True),
        dummies_productos.reset_index(drop=True)
    ], axis=1)

    # Paso 5: predicción
    pred = modelo.predict(df_final)[0]
    return {"otorgar_credito": int(pred)}